*2019년 11월 4일
<요구사항 정의>
myshell에 다음 기능을 추가하기
1) 'cd' 명령이 제대로 작동하지 않는 버그를 수정
:chdir()의 범위는 현재 프로세스에 제한
2) 'exit' 명령을 구현
: fork()를 하지 않고 exit()나 return을 이용함
3) 백그라운드 실행을 구현
: 명령 뒤에 &가 붙으면 백그라운드 실행
: 고아 프로세스의 생성원리를 이용
<구현 방법>
1) chdir()의 범위는 현재 프로세스에 제한이 된다.
즉, fork()로 생성된 자식 프로세스가 chdir()를 실행하게 되면,
부모 프로세스의 cwd가 바뀌지 않고 자식 프로세스의 cwd만 바뀐 채 반환되는 문제가 발생한다.
그렇기 때문에 fork()를 사용하지 않고, 부모 프로세스 내에서 자체적으로 실행을 해야하는 명령어이므로,
fork()처리를 하기 이전에 미리 cd명령어를 감지하여 실행하도록 구현하였다.
그래서 my_cd()라는 함수를 정의하여 부모프로세스 내에서 자체적으로 명령어를 수행하였다.
‘-‘를 입력하면 이전 경로로 갈 수 있도록 옵션도 추가적으로 넣었다. 또한 ‘~’를 입력하거나 혹은 아무 것도 입력하지 않았을 경우에는 getenv()를 이용해 홈디렉토리로 이동하도록 하였다.

2)
exit명령 또한 굳이 fork()를 이용할 필요가 없기 때문에 미리 감지하여 return을 해주도록 구현하였다.

3)
백그라운드의 경우에는 부모 프로세스가 wait을 해주지 않으면 된다.
그러므로 입력받은 커맨드에서 &가 있을 경우, 해당 자식 프로세스는 wait해주지 않도록 구현했다.
또한 포어그라운드의 경우에는 wait을 이용할 경우 어떤 프로세스를 기다리게 될 지 알 수가 없으므로,
waitpid를 이용하여 포어그라운드 명령어를 통해 만들어진 특정 자식프로세스만을 기다리도록 구현하였다.

Ps를 백그라운드로 세번 실행한 뒤, ps를 입력하니 세 개의 좀비프로세스를 발견할 수 있었다.
이는 백그라운드 명령이 들어올 경우, 부모프로세스에서 waitpid명령을 넘어가도록 구현했기 때문이다.

또한 sleep 명령도 위와 같이 백그라운드를 기다리지 않고 프롬프트가 잘 출력이 되는 것을 확인할 수 있다.
시간이 지난 뒤에는 프로세스가 <defunct> 상태로 변하여 좀비 프로세스가 되었다.
하지만 이후에 아무리 기다려도 좀비프로세스가 사라지지 않은 채 남아 있다는 문제가 있었다.

<구현 시 문제점>
아무리 기다려도 좀비프로세스가 사라지지 않은 채 남아 있다는 문제가 있었다.
이는 부모 프로세스인 simple_myshell가 아직 죽지 않은 상황이라,
init이 자동으로 좀비프로세스를 수거해가지 않는 상황이라고 생각했다.
그렇기 때문에 완전히 wait을 하지 않기 보다는,
시그널 핸들링을 통해 자식 프로세스가 죽었을 때 부모 프로세스가 거두어들이는 방향으로 구현을 해야겠다는 생각을 했다.
그래서 sigaction을 이용해 자식이 죽었을 경우 waitpid를 하여 거두어들이는 코드를 추가하였다.

*2019년 11월 12일
<요구사항 정의>
1) SIGCHLD로 자식 프로세스 wait() 시 프로세스가 온전하게 수행되도록 구현
2) ^C(SIGINT), ^ \(SIGQUIT) 사용시 쉘이 종료되지 않도록,
Foreground 프로세스 실행 시 SIGINT를 받으면 프로세스가 끝나는 것을 구현

<구현 방법>
1)
(구현시 문제점)
처음에는 부모 프로세스에서 waitpid를 통해 포어그라운드 프로세스를 기다리고,
그 외의 백그라운드 프로세스는 시그널을 이용해 처리하려고 했다.
하지만 시그널이 발생하여 핸들링을 한 뒤에 돌아오면, 기존에 포어그라운드를 wait하고 있던 라인이 넘어가버려서,
포어그라운드 프로세스가 백그라운드로 변해버리는 불상사가 일어났다.
(해결법)
이를 해결하기 위해 약간의 편법을 이용해보았다.
Pid_t pid변수를 전역으로 선언하고, 시그널 핸들링 함수 내에서도 접근이 가능하도록 만들었다.
이때, pid에는 항상 현재 포어그라운드로 실행되고 있는 프로세스의 pid가 저장되어 있다.
그러므로 만약 SIGCHLD로 받은 프로세스가 포어그라운드 프로세스였다면,
waitpid을 한 다음 pid값을 -1로 바꾸어주고, 그렇지 않았다면 waitpid를 한 다음 그냥 아무런 조치도 취하지 않았다.
그렇게 되면 시그널을 처리하고 부모 프로세스(쉘)로 다시 되돌아왔을 때
waitpid를 하고 있던 라인의 다음줄을 실행하게 되더라도,
while문을 걸어서 포어그라운드 프로세스가 백그라운드로 전환되어버리는 경우를 없앴다.
물론 탈출조건은 pid=-1인 경우이거나, waitpid가 성공했을 경우이다.
아래는 main의 바깥에 전역으로 선언된 pid를 보여주며, SIGCHILD를 받는 시그널 핸들링 함수인 background_signal을 보여준다.

pid_t pid;
void background_signal(int sig){
if(pid==waitpid(-1,(int*)NULL,WNOHANG)) pid = -1;
}

또한 아래는 fork()이후에 부모 프로세스 부분에서 while문을 걸어서 계속해서 포어그라운드 프로세스의 종료를 기다리는 코드를 보여준다.

switch(pid=fork()){
case 0:
setpgid(0,0);
signal(SIGQUIT,SIG_DFL);
signal(SIGINT,SIG_DFL);
signal(SIGTSTP,SIG_DFL);
if(!background) tcsetpgrp(STDIN_FILENO,getpgid(0));

execvp(cmdvector[0],cmdvector);
fetal("main()");
default:
    if(!background){
    while(1){
    if(pid != -1){
    if(pid == waitpid(pid,(int*)NULL,WUNTRACED)) break;
    }
    else break;
    }
    tcsetpgrp(STDIN_FILENO,getpgid(0));
    }
}

아래는 테스트 사항에 대한 결과이다.

myshell> sleep 20 &
myshell> sleep 30 &
myshell> sleep 50
myshell> ps
  PID TTY TIME  CMD
  2028  pts/0 00:00:00  bash
  2112  pts/0 00:00:00  simple_myshell
  2119  pts/0 00:00:00  ps
myshell>

2)
먼저 쉘에서 인터럽트를 받아도 종료되지 않게 하기 위해서
SIGINT,SIGQUIT,SIGTSTP를 모두 SIG_IGN으로 설정하였다.
또한 자식 프로세스에서 setpgid(0,0)을 실행하여 프로세스 그룹아이디를 분리시켰다.
또한 자식 프로세스에서는 시그널을 다시 디폴트값으로 되돌려 놓았다.
또한 포어그라운드 프로세스였을 경우에는 제어 터미널의 제어권을 획득하기 위해
tcsetpgrp을 이용하여 STDIN의 제어권을 획득하였다.
아래는 테스트 사항에 대한 결과이다.
쉘에서 인터럽트가 걸려도 죽지 않는 것을 확인할 수 있다.

myshell> ^Z
myshell> ^C
myshell> ^\
myshell>

아래는 포어그라운드 프로세스를 인터럽트로 종료시키는 테스트이다.

myshell> sleep 30
^Cmyshell>


*2019년 11월 20일
<요구사항 정의>
1) Redirection  처리 기능
2) 파이프 처리 기능

<구현 방법>
1)
입력된 cmdvector에서 >혹은 <를 찾아서 dup2를 이용해 리다이렉션을 수행했다.
(구현시 문제점) cat을 이용해 리다이렉션을 수행할 때 ctrl+D를 입력하는 순간
쉘까지 종료가 되어버렸다.
이를 막기 위해 ctrl+D에 해당하는 시그널을 무시해보려고 했으나,
ctrl+D는 시그널이 아니라, EOF에 해당했다.
따라서 환경변수를 조작하여 EOF를 무시하도록 건드려야 하는 것 같았으나, 방법을 잘 몰라서 해결하지 못했다.
따라서 아래의 예제에서는 ctrl+D가 아니라 ctrl+C로 입력을 중단하였다.

myshell> cat > test.txt
12345
abcde
^Cmyshell> cat < test.txt
12345
abcde
myshell> cat < test.txt > test1.txt
myshell> cat test1.txt
12345
abcde
myshell>

2) 파이프 처리는 반복문을 사용하여 파이프 기호 ‘|’를 만날 때마다
fork()를 하여 구현하였다.
먼저 ‘|’를 만나면 왼쪽과 오른쪽 명령어를 나눈 뒤,
 파이프를 통해 연결해주고, 나머지 오른쪽은 다시 반복문을 돌아
 파이프 기호가 있는지 검사하고, 또다시 ‘|’를 만나면
 다시 왼쪽과 오른쪽으로 나누는 방식으로 구현하였다.
 파이프 기호가 없는 경우 반복문을 탈출하여, 리다이렉션을 검사한 뒤 프로세스를 실행한다.

아래는 리다이렉션을 백그라운드로 처리한 화면이다. 
백그라운드로 실행했기 때문에 바로 프롬프트가 출렸되었고,
ls 명령어는 수행시간이 짧은 명령어 이기 때문에 포어그라운드에
새로운 명령을 입력하기도 전에 바로 종료가 되었다.
그러므로 SIGCHILD를 수행하고 다시 되돌아왔을 때는
커맨드에 아무것도 입력하지 않은 채로 다음 라인으로 이동하게 되므로,
결국 아무 입력도 하지 않은 것이 되어
프롬프트 2개가 정상적으로 출력이 되었다.

myshell> ls -l > ls.txt &
myshell> myshell>

이를 방지하기 위해서 cmd입력시 꼭 개행문자가 입력된 경우만 새로운 프롬프트를 출력하도록 코드를 수정하였다.
그랬더니 아래와 같이 프롬프트가 정상적으로 1개만 출력되었다.

myshell> ls -l > ls.txt &
myshell>
